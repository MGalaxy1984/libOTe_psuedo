import SenderHash
from Block import Block
from PRNG2 import PRNG2
from PseudoAES import PseudoAES

aes = [PseudoAES(3242342), PseudoAES(8993849)]
num_threads = 1
m_pnt_count = 128
m_value = []


def component(delta: Block, seed: Block, output: list[Block]):
    """
    :param delta: INPUT a block. Generated by PRNG in the silentSend() function
    :param seed: INPUT a block. Generated by PRNG as the seed of GGM tree
    :param output: OUTPUT a list of blocks. A sublist of mB vector (size = mSizePer * mNumPartitions)
    """
    for i in range(0, 128, 8):
        print(i)


def pre_component(delta: Block):
    for i in range(128):
        m_value.append(Block(delta))


def b_component(root: list[Block]):
    m_out = []
    levels = [[root], [], [], []]
    for i in range(0, 3):
        for j in range(1 << i):
            tmp = levels[i][j]
            left = aes[0].encrypt_8_blocks(tmp)
            for k in range(8):
                left[k] ^= tmp[k]
            right = aes[1].encrypt_8_blocks(tmp)
            for k in range(8):
                right[k] ^= tmp[k]
            levels[i + 1].append(left)
            levels[i + 1].append(right)
    for i in range(8):
        for j in range(8):
            m_out.append(levels[3][i][j])
            # print(levels[3][i][j])
    return m_out


class CNode:
    c_aes = [PseudoAES(3242342), PseudoAES(8993849)]
    data_in = None

    # left_out = None
    # right_out = None

    def __init__(self):
        self.data_in = []
        # self.left_out = []
        # self.right_out = []
        for i in range(8):
            self.data_in.append(Block(0))
            # self.left_out.append(Block(0))
            # self.right_out.append(Block(0))
        # print(len(self.data_in))
        assert (len(self.data_in) == 8)
        # print(len(self.left_out))
        # assert (len(self.left_out) == 8)
        # print(len(self.right_out))
        # assert (len(self.left_out) == 8)

    def run(self):
        di = self.data_in
        assert (len(di) == 8)
        # print(len(self.left_out))
        # print(len(self.right_out))
        # assert (len(self.left_out) == 8)
        # assert (len(self.left_out) == 8)
        tmp_left = self.c_aes[0].encrypt_8_blocks(di)
        for k in range(8):
            tmp_left[k] = di[k] ^ tmp_left[k]

        tmp_right = self.c_aes[1].encrypt_8_blocks(di)
        for k in range(8):
            tmp_right[k] ^= di[k]

        return tmp_left, tmp_right

    def set(self, di: list[Block]):
        self.data_in = di


def c_component(root: list[Block]):
    m_out = []
    nodes = []
    for i in range(8):
        tmp = CNode()
        nodes.append(tmp)

    nodes[0].set(root)
    for i in range(3):
        tmp = []
        for j in range(4):
            tl, tr = nodes[j].run()
            tmp.append(tl)
            tmp.append(tr)
        for j in range(4):
            nodes[j * 2].set(tmp[j * 2])
            nodes[j * 2 + 1].set(tmp[j * 2 + 1])

    for i in range(8):
        m_out += nodes[i].data_in

    # for b in m_out:
    # print(b)
    # print(len(m_out))
    return m_out


class DNode:
    d_aes = [PseudoAES(3242342), PseudoAES(8993849)]
    data_in = None

    # left_out = None
    # right_out = None

    def __init__(self):
        self.data_in = Block(0)

    def run(self):
        di = self.data_in
        tmp_left = self.d_aes[0].encrypt_1_block(di)
        tmp_left ^= di

        tmp_right = self.d_aes[1].encrypt_1_block(di)
        tmp_right ^= di

        return tmp_left, tmp_right

    def set(self, di: Block):
        self.data_in = di


def d_component(root: Block, d: int):
    m_out = []
    nodes = []
    n = 2 ** d
    for i in range(n):
        tmp = DNode()
        nodes.append(tmp)

    nodes[0].set(root)
    for i in range(d):
        tmp = []
        for j in range(n):
            tl, tr = nodes[j].run()
            tmp.append(tl)
            tmp.append(tr)
        for j in range(n // 2):
            nodes[j * 2].set(tmp[j * 2])
            nodes[j * 2 + 1].set(tmp[j * 2 + 1])

    for i in range(n):
        m_out.append(nodes[i].data_in)

    # for b in m_out:
    # print(b)
    # print(len(m_out))
    return m_out


def e_component(seed: Block, d: int):
    n = 2 ** d
    if seed is None:
        seed = Block(0)
    prng2 = PRNG2(seed)
    memory = [Block(0)] * (n * 8)
    for i in range(8):
        memory[i] = prng2.get()
        print(f'prng[{i}] = {memory[i]}')
    ee_calculation(memory, d)
    for i in range(len(memory)):
        print(f'expand[{i}] = {memory[i]}')
    delta = Block(0x2e2b34ca59fa4c883b2c8aefd44be966)
    msg = []
    for i in range(n*8):
        msg.append([Block(0), Block(0)])
    SenderHash.a_component(r=memory, m=msg, delta=delta)
    for i in range(len(msg)):
        print(f'msg[{i}] = {msg[i][0]} {msg[i][1]}')


def e_calculation(memory: list[Block], d: int):
    n = 2 ** d
    e_aes = [PseudoAES(3242342), PseudoAES(8993849)]
    i = 0
    width = 1
    while i < d:
        # j = 2 ** i - 1
        # print(f'i = {i}, width = {width}')
        j = width - 1
        while j >= 0:
            read_addr = j * 8
            left_addr = read_addr * 2
            right_addr = read_addr * 2 + 8
            k = 0
            while k < 8:
                b = memory[read_addr + k]
                left = e_aes[0].encrypt_1_block(b) ^ b
                memory[left_addr + k] = left
                right = e_aes[1].encrypt_1_block(b) ^ b
                memory[right_addr + k] = right
                k += 1
            j -= 1
        i += 1
        width <<= 1


def ee_calculation(memory: list[Block], d: int):
    ee_aes = [PseudoAES(3242342), PseudoAES(8993849)]
    i = 0
    width = 1
    while i < d:
        # j = 2 ** i - 1
        # print(f'i = {i}, width = {width}')
        j = width - 1
        while j >= 0:
            read_addr = j * 8
            left_addr = read_addr * 2
            right_addr = read_addr * 2 + 8

            b = memory[read_addr: read_addr + 8]
            left = ee_aes[0].encrypt_8_blocks(b)
            for k in range(8):
                memory[left_addr + k] = left[k] ^ b[k]
            right = ee_aes[1].encrypt_8_blocks(b)
            for k in range(8):
                memory[right_addr + k] = right[k] ^ b[k]

            j -= 1
        i += 1
        width <<= 1


def ee_test():
    d = 3
    seed = Block(0)
    e_component(seed, d)


def e_test():
    fi = open(f'E:\PycharmProjects\libOTe_psuedo\DataFiles\sender_expand_input_root.txt')
    root = []
    for i in range(128):
        line = fi.readline()
        root.append(Block(int("0x" + line.rstrip(), 16)))
    fi.close()

    output = []
    fi = open(f'E:\PycharmProjects\libOTe_psuedo\DataFiles\sender_expand_output.txt')
    for i in range(1024):
        line = fi.readline()
        output.append(Block(int("0x" + line.rstrip(), 16)))

    e = []
    for g in range(0, 128, 8):
        r = root[g:g + 8]
        tmp_e = [Block(0)] * (8 * 8)
        for i in range(8):
            tmp_e[i] = r[i]
        ee_calculation(tmp_e, 3)
        e += tmp_e

    match = True
    for i in range(len(e)):
        # print(f'i = {i} {b[i]} {c[i]}')
        if e[i] != output[i]:
            match = False
            print(f'i = {i} {output[i]} {e[i]}')
    print(match)


def d_test():
    root = Block(0)
    m_out = d_component(root, 3)
    for i in range(len(m_out)):
        print(f'#{i}: {m_out[i]}')


# for n = 1024
def test():
    n = 1024
    delta = Block(0)
    seed = Block(0)
    # output = []
    # for i in range(n):
    #     output.append(Block(0))
    # component(delta, seed, output)
    fi = open(f'E:\PycharmProjects\libOTe_psuedo\DataFiles\sender_expand_input_root.txt')
    root = []
    for i in range(128):
        line = fi.readline()
        root.append(Block(int("0x" + line.rstrip(), 16)))
    fi.close()

    output = []
    fi = open(f'E:\PycharmProjects\libOTe_psuedo\DataFiles\sender_expand_output.txt')
    for i in range(n):
        line = fi.readline()
        output.append(Block(int("0x" + line.rstrip(), 16)))

    b = []
    c = []
    for g in range(0, 128, 8):
        r = root[g:g + 8]
        bl = b_component(r)
        b += bl
        cl = c_component(r)
        c += cl

    match = True
    for i in range(len(b)):
        # print(f'i = {i} {b[i]} {c[i]}')
        if c[i] != output[i]:
            match = False
            print(f'i = {i} {output[i]} {c[i]}')
    print(match)

    # match = True
    # for i in range(len(b)):
    #     print(f'i = {i} {b[i]} {c[i]}')
    #     if b[i] != c[i]:
    #         match = False
    # print(match)
