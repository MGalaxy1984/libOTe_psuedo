from Block import Block
from PseudoAES import PseudoAES

aes = [PseudoAES(3242342), PseudoAES(8993849)]
num_threads = 1
m_pnt_count = 128
m_value = []


def component(delta: Block, seed: Block, output: list[Block]):
    """
    :param delta: INPUT a block. Generated by PRNG in the silentSend() function
    :param seed: INPUT a block. Generated by PRNG as the seed of GGM tree
    :param output: OUTPUT a list of blocks. A sublist of mB vector (size = mSizePer * mNumPartitions)
    """
    for i in range(0, 128, 8):
        print(i)


def pre_component(delta: Block):
    for i in range(128):
        m_value.append(Block(delta))


def b_component(root: list[Block]):
    m_out = []
    levels = [[root], [], [], []]
    for i in range(0, 3):
        for j in range(1 << i):
            tmp = levels[i][j]
            left = aes[0].encrypt_8_blocks(tmp)
            for k in range(8):
                left[k] ^= tmp[k]
            right = aes[1].encrypt_8_blocks(tmp)
            for k in range(8):
                right[k] ^= tmp[k]
            levels[i + 1].append(left)
            levels[i + 1].append(right)
    for i in range(8):
        for j in range(8):
            m_out.append(levels[3][i][j])
            # print(levels[3][i][j])
    return m_out


class CNode:
    c_aes = [PseudoAES(3242342), PseudoAES(8993849)]
    data_in = None

    # left_out = None
    # right_out = None

    def __init__(self):
        self.data_in = []
        # self.left_out = []
        # self.right_out = []
        for i in range(8):
            self.data_in.append(Block(0))
            # self.left_out.append(Block(0))
            # self.right_out.append(Block(0))
        # print(len(self.data_in))
        assert (len(self.data_in) == 8)
        # print(len(self.left_out))
        # assert (len(self.left_out) == 8)
        # print(len(self.right_out))
        # assert (len(self.left_out) == 8)

    def run(self):
        di = self.data_in
        assert (len(di) == 8)
        # print(len(self.left_out))
        # print(len(self.right_out))
        # assert (len(self.left_out) == 8)
        # assert (len(self.left_out) == 8)
        tmp_left = self.c_aes[0].encrypt_8_blocks(di)
        for k in range(8):
            tmp_left[k] = di[k] ^ tmp_left[k]

        tmp_right = self.c_aes[1].encrypt_8_blocks(di)
        for k in range(8):
            tmp_right[k] ^= di[k]

        return tmp_left, tmp_right

    def set(self, di: list[Block]):
        self.data_in = di


def c_component(root: list[Block]):
    m_out = []
    nodes = []
    for i in range(8):
        tmp = CNode()
        nodes.append(tmp)

    nodes[0].set(root)
    for i in range(3):
        tmp = []
        for j in range(4):
            tl, tr = nodes[j].run()
            tmp.append(tl)
            tmp.append(tr)
        for j in range(4):
            nodes[j * 2].set(tmp[j * 2])
            nodes[j * 2 + 1].set(tmp[j * 2 + 1])

    for i in range(8):
        m_out += nodes[i].data_in

    # for b in m_out:
    # print(b)
    # print(len(m_out))
    return m_out


# for n = 1024
def test():
    n = 1024
    delta = Block(0)
    seed = Block(0)
    # output = []
    # for i in range(n):
    #     output.append(Block(0))
    # component(delta, seed, output)
    fi = open(f'E:\PycharmProjects\libOTe_psuedo\DataFiles\sender_expand_input_root.txt')
    root = []
    for i in range(128):
        line = fi.readline()
        root.append(Block(int("0x" + line.rstrip(), 16)))
    fi.close()

    output = []
    fi = open(f'E:\PycharmProjects\libOTe_psuedo\DataFiles\sender_expand_output.txt')
    for i in range(n):
        line = fi.readline()
        output.append(Block(int("0x" + line.rstrip(), 16)))

    b = []
    c = []
    for g in range(0, 128, 8):
        r = root[g:g + 8]
        bl = b_component(r)
        b += bl
        cl = c_component(r)
        c += cl

    match = True
    for i in range(len(b)):
        # print(f'i = {i} {b[i]} {c[i]}')
        if c[i] != output[i]:
            match = False
            print(f'i = {i} {output[i]} {c[i]}')
    print(match)

    # match = True
    # for i in range(len(b)):
    #     print(f'i = {i} {b[i]} {c[i]}')
    #     if b[i] != c[i]:
    #         match = False
    # print(match)
